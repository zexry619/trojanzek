use worker::*;
use std::collections::{HashSet, HashMap};
use reqwest::Client;
use tokio::{sync::OnceCell};
use http::Uri;

static HOP_HEADERS: OnceCell<HashSet<String>> = OnceCell::const_new();
static REGISTRY: &str = "registry-1.docker.io";

async fn get_hop_headers() -> HashSet<String> {
    let mut headers = HashSet::new();
    
    // RFC 2616 
    headers.insert("connection".to_string());
    headers.insert("keep-alive".to_string());
    headers.insert("proxy-authenticate".to_string());
    headers.insert("proxy-authorization".to_string());
    headers.insert("te".to_string());
    headers.insert("trailer".to_string());
    headers.insert("transfer-encoding".to_string());
    headers.insert("upgrade".to_string());
    
    // generated by proxy
    headers.insert("x-forwarded-for".to_string());
    headers.insert("x-forwarded-host".to_string());
    headers.insert("x-forwarded-proto".to_string());
    headers.insert("x-real-ip".to_string());
    headers.insert("via".to_string());
    headers.insert("x-forwarded-port".to_string());
    headers.insert("x-forwarded-server".to_string());

    // Cloudflare headers
    //headers.insert("cf-connecting-ip".to_string()); // use this otherwise visit cf-cdn blocked.
    headers.insert("cf-ray".to_string());
    headers.insert("cf-ipcountry".to_string());
    headers.insert("cf-request-id".to_string());

    headers
}

pub async fn image_handler(req: Request) -> Result<Response> {

    let domain   = req.query().map_or(REGISTRY, |query: HashMap<String, String>| {
        match query.get("ns").map(|s| s.as_str()) {
            Some("gcr.io") => "gcr.io",
            Some("quay.io") => "quay.io",
            Some("ghcr.io") => "ghcr.io",
            Some("registry.k8s.io") => "registry.k8s.io",
            _ => REGISTRY,
        }
    });
    if let Ok(url) = format!("https://{}{}", domain, req.url()?.path()).parse::<Uri>() {                   
        return handler(req,  url).await;
    }
    return Response::error( "Not Found",404);
}

pub async fn handler(mut req: Request, uri: Uri) -> Result<Response> {
    let client = Client::new();

    let method = match req.method() {
        worker::Method::Get => reqwest::Method::GET,
        worker::Method::Post => reqwest::Method::POST,
        worker::Method::Put => reqwest::Method::PUT,
        worker::Method::Delete => reqwest::Method::DELETE,
        worker::Method::Head => reqwest::Method::HEAD,
        worker::Method::Options => reqwest::Method::OPTIONS,
        worker::Method::Patch => reqwest::Method::PATCH,
        _ => return Response::error("Not supported method", 404),
    };
    let hops = HOP_HEADERS.get_or_init(|| async {
        get_hop_headers().await
    }).await;

    let myhost = req.headers().get("host")?.ok_or("Host header not found")?;

    let mut request_builder = client.request(method, uri.to_string());
    for (key, value) in req.headers().entries() {
        if hops.contains(key.as_str()) {
            continue;
        }
        request_builder = request_builder.header(&key, value);
    }
    request_builder = request_builder.header("Host", uri.host().unwrap());
    
    if let Ok(body) = req.bytes().await {
        if !body.is_empty() {
            request_builder = request_builder.body(body);
        }
    }
    console_debug!("Request: {:?}, header:{:?}",uri.to_string(), req.headers());
    match request_builder.send().await {
        Ok(response) => {
            let status = response.status().as_u16();
            let headers = Headers::new();

            for (key, value) in response.headers().iter() {
                if let Ok(value) = value.to_str() {
                    if hops.contains(key.as_str()) {
                        continue;
                    }
                    // as client, not support content-encoding
                    if key == "content-encoding" {
                        continue;
                    }
                    match status {
                        301 | 302 | 303 | 307 | 308 => {
                             if key == "location" {
                                if value.starts_with('/') {
                                    let modified_value = format!("/{}{value}",uri.host().unwrap());
                                    headers.append(key.as_str(), &modified_value)?;
                                    continue;
                                }
                                if value.starts_with("https://") {
                                   let modified_value = value.replace("https://", &format!("https://{}/)",myhost.as_str()));
                                    headers.append(key.as_str(), &modified_value)?;
                                    continue; 
                                }
                            }
                        }
                        401 => {
                            if key == "www-authenticate" {
                                let modified_value = value.replace("https://", &format!("https://{}/",myhost.as_str()));
                                headers.append(key.as_str(), &modified_value)?;
                                continue;
                            }
                        }
                        _ => {}
                    } 
                    headers.append(key.as_str(), value)?;
                }
            }
            
            let body = response.bytes().await.map_err(|e| {
                console_error!("Failed to read response body: {:?}", e);
                Error::RustError(format!("Failed to read response body: {:?}", e))
            })?;
            
            return Ok(Response::builder()
                .with_status(status)
                .with_headers(headers)
                .body(ResponseBody::Body(body.to_vec())));
        }
        Err(e) => {
            return Response::error(e.to_string(), 500);
        }
    };
} 